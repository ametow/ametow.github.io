[{"content":"Introduction Go has a built-in dynamic array type called slice. It\u0026rsquo;s the most common data structure in the language and extremely powerful. This article explores what slices are and how to use them.\nArrays Slices are an abstraction layer built on top of arrays in Go. To understand slices, we must first understand arrays.\nAn array is a fixed-size data structure that stores elements of the same type in contiguous memory, providing constant-time access through indices. Arrays are defined as follows:\nvar nums [4]int The variable nums is of type [4]int. An array\u0026rsquo;s size is part of its type, so [6]int is an entirely different type.\nWe set elements using indices:\nnums[0] = 11 nums[3] = 12 i := nums[3] // i = 12 If we try to assign outside of the bounds, we get a compile-time error:\nnums[5] = 23 // invalid argument: index 5 out of bounds [0:4] Arrays don\u0026rsquo;t need to be initialized explicitly; the zero value of an array is a ready-to-use array whose elements are zeroed:\nfmt.Println(nums) // [11 0 0 12] The representation of this array is simply four integer values laid out sequentially:\nUnlike in C, arrays in Go are values, not pointers to the first element. This means when you assign or pass an array, you make a copy of its contents.\nnums := [3]int{12,14,16} processArray(nums) // nums[0] = 12 still } func processArray(nums [3]int) { nums[0] = 15 } To avoid copying, you can pass a pointer to the array, though this makes it a pointer to an array rather than an array itself:\nprocessArray(\u0026amp;nums) } func processArray(nums *[3]int) { ... } Slices Arrays are inflexible and therefore uncommon in Go code. Slices, being dynamically resizable, build on arrays to provide greater convenience. You can think of a slice as a struct with three fields:\n// imaginary type type Slice struct { data *[10]int length int capacity int } The data field is a pointer to the underlying array. length is the number of elements the slice currently holds, and capacity defines how many elements the slice can hold before increasing the underlying array\u0026rsquo;s size. A slice can be created with the built-in function make:\n// func make([]T, length, capacity) []T mySlice := make([]int, 10, 10) // a slice with len = 10 and cap = 10 print(mySlice, len(mySlice), cap(mySlice)) // [0 0 0 0 0 0 0 0 0 0], 10, 10 Here, T represents the element type of the slice to be created. The capacity argument is optional—if omitted, it defaults to the specified length. You can inspect a slice\u0026rsquo;s length and capacity using the built-in len and cap functions.\nWhen called, make allocates an array and returns a slice that refers to that array.\nA slice literal is declared like an array literal, but without the element count:\nletters := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;} The zero value of a slice is nil:\nvar nums []int print(nums == nil) // true print(len(nums), cap(nums)) // 0, 0 You can also create a slice by \u0026ldquo;slicing\u0026rdquo; an existing slice or array using a half-open range with two indices separated by a colon:\nb := []int{1,2,3,4,5,6} c := b[1:3] // []int{2,3} Variable c is a new slice that refers to the same storage as b with length 2 and capacity 5.\nBy default, capacity is the number of elements in the underlying array (beginning at the element referred to by the slice pointer). However, you can specify the capacity explicitly with this syntax:\nc := b[1:3:3] // []int{2,3}, len = 2, cap = 3 The third number specifies the capacity of the newly created slice. A slice cannot be grown beyond its capacity, appending to it with append will allocate a new underlying array. Similarly it cannot be re-sliced below zero to access earlier elements in the array.\nThe start and end indices are optional—they default to zero and the length of the slice respectively:\nc := b[:] // == b // c := b[2:] == []int{3,4,5,6} // c := b[:2] == []int{1,2} Since slices share the underlying array, changing values in one slice is reflected on the others:\nc[0] = 77 print(b) // [1,77,3,4,5,6] print(c) // [77, 3] This is also the syntax to create a slice from an array:\nnums := [4]int{12,13,14,15} numSlice := nums[2:] // new slice refers to nums array, len = 2, cap = 2 ","permalink":"https://arslanbek.com/posts/go-slices/","summary":"Slices in Go, internals of usage","title":"Golang slices "},{"content":"🌟 What is Rate Limiting? Imagine you\u0026rsquo;re at your favorite coffee shop. The barista can only make so many drinks per minute. If too many people order at once, they have to wait or come back later. ☕️ That\u0026rsquo;s exactly how rate limiting works in the digital world!\nRate limiting is a technique used in software systems to control the number of requests a user, IP address, or service can send within a given time frame. This helps prevent spam, abuse, and overloading of resources. 💡\n🎯 Why Do We Need Rate Limiting? Rate limiting isn’t just some arbitrary restriction—it plays a crucial role in keeping online systems stable, secure, and fair. Here’s why it matters:\n🛑 Prevents Abuse \u0026amp; Spam – Stops a single user from making too many requests and overwhelming the system. ⚖️ Ensures Fair Usage – Prevents a few users from hogging all the resources so that everyone gets a fair chance. 💻 Protects Server Resources – Helps prevent server crashes and keeps things running smoothly. 🔒 Enhances Security – Mitigates threats like brute-force attacks and DDoS attacks that can take down services. 🕵️‍♂️ Real-World Examples of Rate Limiting Login Attempts 🔐: Many websites limit login attempts to prevent hackers from guessing passwords. API Requests 📡: Services like Twitter, Google, and GitHub limit how many requests you can make per second. Online Ticket Booking 🎟️: Websites prevent bots from buying up all the tickets for concerts and events. 🔄 How Does Rate Limiting Work? Rate limiting works by keeping track of recent requests. If a user sends too many within a short time, some requests get blocked.\nThere are a few common strategies:\n⏳ Fixed Window Imagine a store that allows only 10 customers per hour. If 10 people enter at 10 AM, no more are allowed in until 11 AM. Simple but can cause spikes in traffic at window resets. 📊 Sliding Window Like a rolling queue where we count requests over the last 60 seconds, regardless of when they occurred. More precise and fair than the fixed window. 💰 Token Bucket Users start with a set number of tokens (requests). Tokens regenerate at a fixed rate. A request can only be made if there are enough tokens available. This is often used for APIs to allow occasional bursts of requests. 💻 Implementing Rate Limiting in Golang 🎉 Now, let’s get our hands dirty with some Golang code! We will implement a simple rate limiter using a map to track requests per IP and a queue to manage time-based limits.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;container/list\u0026#34; ) type RequestLog struct { requests *list.List } func rateLimiter(timestamps []int64, ipAddresses []string, limit int, timeWindow int64) []int { requestLog := make(map[string]*RequestLog) result := make([]int, len(timestamps)) for i, timestamp := range timestamps { ip := ipAddresses[i] if _, exists := requestLog[ip]; !exists { requestLog[ip] = \u0026amp;RequestLog{requests: list.New()} } log := requestLog[ip] // Remove outdated requests for log.requests.Len() \u0026gt; 0 { front := log.requests.Front() if front.Value.(int64) \u0026lt; timestamp-timeWindow { log.requests.Remove(front) } else { break } } // Check if we can accept the request if log.requests.Len() \u0026lt; limit { log.requests.PushBack(timestamp) result[i] = 1 // Accept request ✅ } else { result[i] = 0 // Reject request ❌ } } return result } func main() { timestamps := []int64{1600040547954, 1600040547957, 1600040547958} ipAddresses := []string{\u0026#34;127.105.232.211\u0026#34;, \u0026#34;127.105.232.211\u0026#34;, \u0026#34;127.105.232.211\u0026#34;} limit := 1 timeWindow := int64(3) result := rateLimiter(timestamps, ipAddresses, limit, timeWindow) fmt.Println(result) // Output: [1, 0, 1] } 🚀 How This Code Works: 📝 Tracking Requests – We store each IP\u0026rsquo;s request timestamps in a queue. 🗑️ Removing Old Requests – We remove requests that are outside the allowed time window before processing new ones. ✅ Accepting or ❌ Rejecting Requests – If the number of requests in the time window is below the limit, we accept the request (1). Otherwise, we reject it (0). 🏆 Enhancements \u0026amp; Next Steps If you want to make this even better, try:\n🌍 Using Redis – For distributed rate limiting across multiple servers. 📈 Adaptive Rate Limiting – Adjust limits dynamically based on user behavior. 🚧 Implementing Token Bucket Algorithm – To allow burst requests. 🕒 Logging \u0026amp; Monitoring – Keep track of rate limit violations for security analysis. 🎉 Wrapping Up Rate limiting is a powerful tool that keeps services running smoothly and fairly. Whether you\u0026rsquo;re building an API, a website, or a login system, adding rate limiting can protect your server while ensuring a great user experience. 🏆\n💡 Now it\u0026rsquo;s your turn! How would you implement rate limiting in your own projects? Let’s discuss! 🚀\n","permalink":"https://arslanbek.com/posts/mastering-rate-limiting/","summary":"Rate limiting fundamentals and Go implementation","title":"Rate limiting"}]